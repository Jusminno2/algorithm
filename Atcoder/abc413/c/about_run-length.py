"""
ランレングス圧縮とは？

- 本質；
    ・連続した同一の値を「値 × 繰り返し数」のペアに置き換えることで、冗長性を削減する
    ・長さ N の配列 A を、連続する同じ値ごとに (値, 個数) のペアに圧縮することで、計算量やメモリを削減する

        # 例：A = [3, 3, 3, 1, 1, 4]
        # RLE表現 → [(3, 3), (1, 2), (4, 1)]

- 使用場面：
    ・メモリ制約突破（サイズ制限回避）
        -> 配列 A の長さが最大 10^14 など「物理的に保持できない」場合、RLE によって「操作対象は Q 個以下のペア」になる
    ・時間計算量削減（無駄なループを回避）
        -> 例：A = [1]*100000 + [2]*100000 みたいに値が連続しているとき、
            -> ループで1個ずつ処理せず、RLEで一気に 個数 × 値 として処理可能
    ・特定の操作を効率化（前から削除・後ろに追加・まとめて集計）
        -> 「左から K 個削除」「最後に C 個追加」「値 V が連続して何個かあるとき、集計する」などの場面でO(1)でできる

- 使わない場面：
    ・値がバラバラなら非効率
        -> 	例：[1,2,3,4,5,...] のような配列では RLE にしても全然圧縮できない（むしろ冗長）
    ・ランダムアクセスが難しい
        -> 	A[123456] のような位置アクセスが頻出する場合、RLE は不向き
    ・更新処理にはご注意を
        -> 値の変更・削除をしたときに、ペアの結合・分割が必要になることがある
"""

def build_rle(bits: str):
    """'110001' → [('1',2), ('0',3), ('1',1)]"""
    runs = []
    for b in bits:
        if runs and runs[-1][0] == b:
            runs[-1][1] += 1
        else:
            runs.append([b, 1])
    return runs

# ========== 使い方 ==========
s = "11110000111"
runs = build_rle(s)

def max_one_stretch(l: int, r: int) -> int:
    """0-indexed, 区間 [l,r] で '1' が続く最大長"""
    pos, best = 0, 0
    for val, ln in runs:
        nxt = pos + ln - 1
        if nxt < l:                     # 区間より左
            pos = nxt + 1
            continue
        if pos > r:                     # 区間より右
            break
        if val == '1':
            # 区間に重なる部分長
            left = max(pos, l)
            right = min(nxt, r)
            best = max(best, right - left + 1)
        pos = nxt + 1
    return best

print(max_one_stretch(2, 10))   # -> 4
