"""
N = 0 ... 0 0 0 0 0
N = 1 ... 0 1 0 0 0
N = 2 ... 0 1 1 0 0
N = 3 ... 0 1 0 0 0
N = 4 ... 0 1 0 0 1
N = 5 ... 1 1 0 0 1
N = 6 ... 1 1 0 0 0
N = 7 ... 1 0 0 0 0
"""

"""
大事なこと
-> square[i] と square[i+1] が異なるような i の数を求めること

スコープ
-> 考えるスコープをできるだけ小さくしていくことが計算量の短縮につながる
-> 今回で言えば、ある時刻における、i番目のコインの前後を確認すること

工夫
-> 0番目とN+1番目を確定で白塗りにしておくこと
    -> エッジケースを考えるため -> 1番目とN番目が指定された場合にq-1とq+1にaccess可能になる
    -> なぜ白塗り？ -> q-1 or q+1 で端っこを考えるときにそいつらがもし白であれば余計に区間の数が大きくなる
"""
def main():
    N, Q = map(int, input().split())
    query = list(map(int, input().split()))

    square = [0] * (N + 2)
    ans = 0

    for q in query:
        if square[q-1] == square[q] and square[q] == square[q+1]:
            ans += 1
            square[q] = 1 - square[q]
            print(ans)
        elif square[q-1] != square[q] and square[q] != square[q+1]:
            ans -= 1
            square[q] = 1 - square[q]
            print(ans)
        else:
            ans += 0
            square[q] = 1 - square[q]
            print(ans)


if __name__ == '__main__':
    main()

"""
１．今回の根本的な考え方
- 作戦1；愚直にマス目を反転させ、区間の数を数える -> O(NQ) or O(N^2Q) よりダメ

２．ある時点における区間の数を考える
- マスiとマス(i+1)の色が異なるようなiの個数をkとする
- そのような i を i1, i2, i3, ..., ik とする
    - 0 <= j <= i1 について、マスjは白く塗られている
    - i1 + 1 <= j <= i2 について、マスjは黒く塗られている
    - i2 + 1 <= j <= i3 について、マスjは白く塗られている
    - ⋯⋯
    - ik + 1 <= j <= N+1 について、マスjは白く塗られている
- マス0,(N+1)は常に白く塗られている -> i1+1 からの区間は黒塗り -> 黒白黒白...黒白より、黒塗りは k/2 個
    -> 各クエリを処理した後のマス i とマス (i+1) の色が異なるような iの個数が分かればOK
- じゃあどうやってその数を調べるのか？
    -> 最初は、すべてのマスは白塗りなので、すべてのマスiとマス(i+1)の色は等しい
    -> 次にマスXを反転したときに起こることは以下の通り
        - i = X-1 について、マスiとマス(i+1)の色が等しかったならば異なるようになる。異なっていたならば、等しくなる。
        - i = X について、マスiマス(i+1) の色が等しかったならば異なるようになる。異なっていたならば、等しくなる。
"""