# 入力（A[2], ..., A[N] が入力される値になるようにする）
N = int(input())
A = [0] * 2 + list(map(int, input().split()))

# 隣接リストの作成
G = [ list() for i in range(N+1)]
for i in range(2, N+1):
    G[A[i]].append(i)   # 上司->部下の方向に辺を追加

# 動的計画法（dp[x] は社員 x の部下の数）
dp = [0] * (N+1)
for i in range(N, 0, -1):   # N -> 1 まで
    for j in G[i]:  # G[i] は社員 i の部下リスト
        dp[i] += (dp[j] + 1)

# 答え
print(*dp[1:])

"""
問題の前提が大切！
前提：ノード番号が「子より親の方が小さい」構造

    for i in range(N, 0, -1) のループ順で「子ノード → 親ノード」の順になるには、
    → 親ノードの番号 < 子ノードの番号 でなければならない。
    
    なぜなら dp[i] += dp[j] + 1 において、j（子）が すでに処理済みである必要があるから。
    🔺この前提が崩れると dp[j] は未処理のまま使われ、誤った値になる。
"""