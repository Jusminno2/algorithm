N, W = map(int, input().split())
w = [None] * (N + 1)
v = [None] * (N + 1)

for i in range(1, N+1):
    w[i], v[i] = map(int, input().split())

# DP
dp = [[ -10 ** 15 ] * (W+1) for _ in range(N+1)]
dp[0][0] = 0
for i in range(1, N+1):
    for j in range(1, W+1):
        if j < w[i]:
            dp[i][j] = dp[i-1][j]
        if j >= w[i]:
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])

# 出力
print(max(dp[N]))


"""
【疑問】
・なぜ、-10 ** 15 で初期化する必要があったのか、0じゃだめ？
  => max()によって選ばれないようにするため
  => 0というのはその状態がありうるという意味
  => True or False にしてれば問題ないけど、今回は単純なマルバツではなく価値という変数も考慮する必要がある
  
・j < w[i] ってどんなとき？
  => 目標としている重さよりも、追加しようとしている品物の重さがそもそも大きい場合

・dp[i-1][j] と dp[i-1][j-w[i]] + v[i] の違い
　=> そのまま下に下るか、斜めに下るのか

「無限大から次の i について考えるとき、無限大同士の比較を行う場合がある」
→ ✅ その通りです。
DP配列の初期化に -∞（実際には -10**15 など）を使っている場合、
ある状態 dp[i-1][j] や dp[i-1][j - w[i]] が「未到達（-∞）」なら、
次の dp[i][j] も max(-∞, -∞ + v[i]) となる → -∞
"""
